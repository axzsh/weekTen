<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rubik's Cube Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            background: #667eea;
            color: white;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        #status {
            margin-top: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
        }
        h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3>Rubik's Cube</h3>
        <button onclick="scrambleCube()">Scramble Cube</button>
        <button onclick="solveCube()" id="solveBtn">Auto Solve</button>
        <button onclick="resetCube()">Reset Cube</button>
        <div id="status">Click Scramble to start!</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube;
        let cubelets = [];
        let isAnimating = false;
        let moveHistory = [];
        
        const COLORS = {
            white: 0xffffff,
            yellow: 0xffff00,
            green: 0x00ff00,
            blue: 0x0000ff,
            red: 0xff0000,
            orange: 0xff8800
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            createCube();
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        function createCubelet(x, y, z) {
            const size = 0.95;
            const geo = new THREE.BoxGeometry(size, size, size);
            
            const materials = [
                new THREE.MeshLambertMaterial({ color: x === 1 ? COLORS.red : x === -1 ? COLORS.orange : 0x000000 }),
                new THREE.MeshLambertMaterial({ color: x === 1 ? COLORS.red : x === -1 ? COLORS.orange : 0x000000 }),
                new THREE.MeshLambertMaterial({ color: y === 1 ? COLORS.white : y === -1 ? COLORS.yellow : 0x000000 }),
                new THREE.MeshLambertMaterial({ color: y === 1 ? COLORS.white : y === -1 ? COLORS.yellow : 0x000000 }),
                new THREE.MeshLambertMaterial({ color: z === 1 ? COLORS.green : z === -1 ? COLORS.blue : 0x000000 }),
                new THREE.MeshLambertMaterial({ color: z === 1 ? COLORS.green : z === -1 ? COLORS.blue : 0x000000 })
            ];
            
            const cubelet = new THREE.Mesh(geo, materials);
            cubelet.position.set(x, y, z);
            
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geo),
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            cubelet.add(edges);
            
            return cubelet;
        }

        function createCube() {
            cube = new THREE.Group();
            cubelets = [];
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const cubelet = createCubelet(x, y, z);
                        cube.add(cubelet);
                        cubelets.push(cubelet);
                    }
                }
            }
            
            scene.add(cube);
        }

        function rotateFace(axis, layer, direction) {
            return new Promise((resolve) => {
                const angle = direction * Math.PI / 2;
                const group = new THREE.Group();
                scene.add(group);
                
                const selectedCubelets = cubelets.filter(cubelet => {
                    const pos = cubelet.position;
                    if (axis === 'x') return Math.abs(pos.x - layer) < 0.1;
                    if (axis === 'y') return Math.abs(pos.y - layer) < 0.1;
                    if (axis === 'z') return Math.abs(pos.z - layer) < 0.1;
                });
                
                selectedCubelets.forEach(cubelet => {
                    cube.remove(cubelet);
                    group.add(cubelet);
                });
                
                const startTime = Date.now();
                const duration = 300;
                
                function animateRotation() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const currentAngle = angle * progress;
                    
                    group.rotation[axis] = currentAngle;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateRotation);
                    } else {
                        selectedCubelets.forEach(cubelet => {
                            group.remove(cubelet);
                            
                            cubelet.position.applyMatrix4(group.matrix);
                            cubelet.rotation.setFromRotationMatrix(group.matrix);
                            
                            cubelet.position.x = Math.round(cubelet.position.x);
                            cubelet.position.y = Math.round(cubelet.position.y);
                            cubelet.position.z = Math.round(cubelet.position.z);
                            
                            cube.add(cubelet);
                        });
                        
                        scene.remove(group);
                        resolve();
                    }
                }
                
                animateRotation();
            });
        }

        async function executeMove(move) {
            const moves = {
                'R': () => rotateFace('x', 1, 1),
                'L': () => rotateFace('x', -1, -1),
                'U': () => rotateFace('y', 1, 1),
                'D': () => rotateFace('y', -1, -1),
                'F': () => rotateFace('z', 1, 1),
                'B': () => rotateFace('z', -1, -1),
                'Ri': () => rotateFace('x', 1, -1),
                'Li': () => rotateFace('x', -1, 1),
                'Ui': () => rotateFace('y', 1, -1),
                'Di': () => rotateFace('y', -1, 1),
                'Fi': () => rotateFace('z', 1, -1),
                'Bi': () => rotateFace('z', -1, 1)
            };
            
            if (moves[move]) {
                await moves[move]();
            }
        }

        async function scrambleCube() {
            if (isAnimating) return;
            isAnimating = true;
            document.getElementById('solveBtn').disabled = true;
            document.getElementById('status').textContent = 'Scrambling...';
            
            moveHistory = [];
            const allMoves = ['R', 'L', 'U', 'D', 'F', 'B', 'Ri', 'Li', 'Ui', 'Di', 'Fi', 'Bi'];
            const scrambleLength = 20;
            
            for (let i = 0; i < scrambleLength; i++) {
                const move = allMoves[Math.floor(Math.random() * allMoves.length)];
                moveHistory.push(move);
                await executeMove(move);
            }
            
            document.getElementById('status').textContent = 'Scrambled! Click Auto Solve.';
            document.getElementById('solveBtn').disabled = false;
            isAnimating = false;
        }

        async function solveCube() {
            if (isAnimating || moveHistory.length === 0) return;
            isAnimating = true;
            document.getElementById('solveBtn').disabled = true;
            document.getElementById('status').textContent = 'Solving...';
            
            const inverseMoves = {
                'R': 'Ri', 'Ri': 'R',
                'L': 'Li', 'Li': 'L',
                'U': 'Ui', 'Ui': 'U',
                'D': 'Di', 'Di': 'D',
                'F': 'Fi', 'Fi': 'F',
                'B': 'Bi', 'Bi': 'B'
            };
            
            for (let i = moveHistory.length - 1; i >= 0; i--) {
                const inverseMove = inverseMoves[moveHistory[i]];
                await executeMove(inverseMove);
            }
            
            moveHistory = [];
            document.getElementById('status').textContent = 'Solved!';
            isAnimating = false;
        }

        function resetCube() {
            if (isAnimating) return;
            
            scene.remove(cube);
            createCube();
            moveHistory = [];
            document.getElementById('status').textContent = 'Cube reset!';
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isAnimating) {
                cube.rotation.y += 0.003;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>